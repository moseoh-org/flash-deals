// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cancelOrder = `-- name: CancelOrder :one
UPDATE orders.orders
SET status = 'cancelled', cancelled_at = NOW(), cancel_reason = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, total_amount, status, recipient_name, phone, address, address_detail, postal_code, cancelled_at, cancel_reason, created_at, updated_at
`

type CancelOrderParams struct {
	ID           pgtype.UUID `json:"id"`
	CancelReason pgtype.Text `json:"cancel_reason"`
}

func (q *Queries) CancelOrder(ctx context.Context, arg CancelOrderParams) (OrdersOrder, error) {
	row := q.db.QueryRow(ctx, cancelOrder, arg.ID, arg.CancelReason)
	var i OrdersOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TotalAmount,
		&i.Status,
		&i.RecipientName,
		&i.Phone,
		&i.Address,
		&i.AddressDetail,
		&i.PostalCode,
		&i.CancelledAt,
		&i.CancelReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countOrdersByUserID = `-- name: CountOrdersByUserID :one
SELECT COUNT(*) FROM orders.orders WHERE user_id = $1
`

func (q *Queries) CountOrdersByUserID(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countOrdersByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOrdersByUserIDAndStatus = `-- name: CountOrdersByUserIDAndStatus :one
SELECT COUNT(*) FROM orders.orders WHERE user_id = $1 AND status = $2
`

type CountOrdersByUserIDAndStatusParams struct {
	UserID pgtype.UUID       `json:"user_id"`
	Status OrdersOrderStatus `json:"status"`
}

func (q *Queries) CountOrdersByUserIDAndStatus(ctx context.Context, arg CountOrdersByUserIDAndStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOrdersByUserIDAndStatus, arg.UserID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrder = `-- name: CreateOrder :one

INSERT INTO orders.orders (user_id, total_amount, status, recipient_name, phone, address, address_detail, postal_code)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, user_id, total_amount, status, recipient_name, phone, address, address_detail, postal_code, cancelled_at, cancel_reason, created_at, updated_at
`

type CreateOrderParams struct {
	UserID        pgtype.UUID       `json:"user_id"`
	TotalAmount   int32             `json:"total_amount"`
	Status        OrdersOrderStatus `json:"status"`
	RecipientName pgtype.Text       `json:"recipient_name"`
	Phone         pgtype.Text       `json:"phone"`
	Address       pgtype.Text       `json:"address"`
	AddressDetail pgtype.Text       `json:"address_detail"`
	PostalCode    pgtype.Text       `json:"postal_code"`
}

// Order queries
func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (OrdersOrder, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.UserID,
		arg.TotalAmount,
		arg.Status,
		arg.RecipientName,
		arg.Phone,
		arg.Address,
		arg.AddressDetail,
		arg.PostalCode,
	)
	var i OrdersOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TotalAmount,
		&i.Status,
		&i.RecipientName,
		&i.Phone,
		&i.Address,
		&i.AddressDetail,
		&i.PostalCode,
		&i.CancelledAt,
		&i.CancelReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO orders.order_items (order_id, product_id, deal_id, product_name, quantity, unit_price, subtotal)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, order_id, product_id, deal_id, product_name, quantity, unit_price, subtotal, created_at
`

type CreateOrderItemParams struct {
	OrderID     pgtype.UUID `json:"order_id"`
	ProductID   pgtype.UUID `json:"product_id"`
	DealID      pgtype.UUID `json:"deal_id"`
	ProductName string      `json:"product_name"`
	Quantity    int32       `json:"quantity"`
	UnitPrice   int32       `json:"unit_price"`
	Subtotal    int32       `json:"subtotal"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrdersOrderItem, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.OrderID,
		arg.ProductID,
		arg.DealID,
		arg.ProductName,
		arg.Quantity,
		arg.UnitPrice,
		arg.Subtotal,
	)
	var i OrdersOrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.DealID,
		&i.ProductName,
		&i.Quantity,
		&i.UnitPrice,
		&i.Subtotal,
		&i.CreatedAt,
	)
	return i, err
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT id, user_id, total_amount, status, recipient_name, phone, address, address_detail, postal_code, cancelled_at, cancel_reason, created_at, updated_at
FROM orders.orders
WHERE id = $1
`

func (q *Queries) GetOrderByID(ctx context.Context, id pgtype.UUID) (OrdersOrder, error) {
	row := q.db.QueryRow(ctx, getOrderByID, id)
	var i OrdersOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TotalAmount,
		&i.Status,
		&i.RecipientName,
		&i.Phone,
		&i.Address,
		&i.AddressDetail,
		&i.PostalCode,
		&i.CancelledAt,
		&i.CancelReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderForUpdate = `-- name: GetOrderForUpdate :one
SELECT id, user_id, status FROM orders.orders WHERE id = $1 FOR UPDATE
`

type GetOrderForUpdateRow struct {
	ID     pgtype.UUID       `json:"id"`
	UserID pgtype.UUID       `json:"user_id"`
	Status OrdersOrderStatus `json:"status"`
}

func (q *Queries) GetOrderForUpdate(ctx context.Context, id pgtype.UUID) (GetOrderForUpdateRow, error) {
	row := q.db.QueryRow(ctx, getOrderForUpdate, id)
	var i GetOrderForUpdateRow
	err := row.Scan(&i.ID, &i.UserID, &i.Status)
	return i, err
}

const getOrderItemsByOrderID = `-- name: GetOrderItemsByOrderID :many
SELECT id, order_id, product_id, deal_id, product_name, quantity, unit_price, subtotal, created_at
FROM orders.order_items
WHERE order_id = $1
ORDER BY created_at
`

func (q *Queries) GetOrderItemsByOrderID(ctx context.Context, orderID pgtype.UUID) ([]OrdersOrderItem, error) {
	rows, err := q.db.Query(ctx, getOrderItemsByOrderID, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrdersOrderItem
	for rows.Next() {
		var i OrdersOrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.DealID,
			&i.ProductName,
			&i.Quantity,
			&i.UnitPrice,
			&i.Subtotal,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByUserID = `-- name: ListOrdersByUserID :many
SELECT id, user_id, total_amount, status, recipient_name, phone, address, address_detail, postal_code, cancelled_at, cancel_reason, created_at, updated_at
FROM orders.orders
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListOrdersByUserIDParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListOrdersByUserID(ctx context.Context, arg ListOrdersByUserIDParams) ([]OrdersOrder, error) {
	rows, err := q.db.Query(ctx, listOrdersByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrdersOrder
	for rows.Next() {
		var i OrdersOrder
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TotalAmount,
			&i.Status,
			&i.RecipientName,
			&i.Phone,
			&i.Address,
			&i.AddressDetail,
			&i.PostalCode,
			&i.CancelledAt,
			&i.CancelReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByUserIDAndStatus = `-- name: ListOrdersByUserIDAndStatus :many
SELECT id, user_id, total_amount, status, recipient_name, phone, address, address_detail, postal_code, cancelled_at, cancel_reason, created_at, updated_at
FROM orders.orders
WHERE user_id = $1 AND status = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListOrdersByUserIDAndStatusParams struct {
	UserID pgtype.UUID       `json:"user_id"`
	Status OrdersOrderStatus `json:"status"`
	Limit  int32             `json:"limit"`
	Offset int32             `json:"offset"`
}

func (q *Queries) ListOrdersByUserIDAndStatus(ctx context.Context, arg ListOrdersByUserIDAndStatusParams) ([]OrdersOrder, error) {
	rows, err := q.db.Query(ctx, listOrdersByUserIDAndStatus,
		arg.UserID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrdersOrder
	for rows.Next() {
		var i OrdersOrder
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TotalAmount,
			&i.Status,
			&i.RecipientName,
			&i.Phone,
			&i.Address,
			&i.AddressDetail,
			&i.PostalCode,
			&i.CancelledAt,
			&i.CancelReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersWithItemsByUserID = `-- name: ListOrdersWithItemsByUserID :many
SELECT
    o.id AS o_id,
    o.user_id AS o_user_id,
    o.total_amount AS o_total_amount,
    o.status AS o_status,
    o.recipient_name AS o_recipient_name,
    o.phone AS o_phone,
    o.address AS o_address,
    o.address_detail AS o_address_detail,
    o.postal_code AS o_postal_code,
    o.cancelled_at AS o_cancelled_at,
    o.cancel_reason AS o_cancel_reason,
    o.created_at AS o_created_at,
    o.updated_at AS o_updated_at,
    i.id AS i_id,
    i.product_id AS i_product_id,
    i.deal_id AS i_deal_id,
    i.product_name AS i_product_name,
    i.quantity AS i_quantity,
    i.unit_price AS i_unit_price,
    i.subtotal AS i_subtotal,
    i.created_at AS i_created_at
FROM orders.orders o
LEFT JOIN orders.order_items i ON o.id = i.order_id
WHERE o.user_id = $1
ORDER BY o.created_at DESC, i.created_at
LIMIT $2 OFFSET $3
`

type ListOrdersWithItemsByUserIDParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type ListOrdersWithItemsByUserIDRow struct {
	OID            pgtype.UUID        `json:"o_id"`
	OUserID        pgtype.UUID        `json:"o_user_id"`
	OTotalAmount   int32              `json:"o_total_amount"`
	OStatus        OrdersOrderStatus  `json:"o_status"`
	ORecipientName pgtype.Text        `json:"o_recipient_name"`
	OPhone         pgtype.Text        `json:"o_phone"`
	OAddress       pgtype.Text        `json:"o_address"`
	OAddressDetail pgtype.Text        `json:"o_address_detail"`
	OPostalCode    pgtype.Text        `json:"o_postal_code"`
	OCancelledAt   pgtype.Timestamptz `json:"o_cancelled_at"`
	OCancelReason  pgtype.Text        `json:"o_cancel_reason"`
	OCreatedAt     pgtype.Timestamptz `json:"o_created_at"`
	OUpdatedAt     pgtype.Timestamptz `json:"o_updated_at"`
	IID            pgtype.UUID        `json:"i_id"`
	IProductID     pgtype.UUID        `json:"i_product_id"`
	IDealID        pgtype.UUID        `json:"i_deal_id"`
	IProductName   pgtype.Text        `json:"i_product_name"`
	IQuantity      pgtype.Int4        `json:"i_quantity"`
	IUnitPrice     pgtype.Int4        `json:"i_unit_price"`
	ISubtotal      pgtype.Int4        `json:"i_subtotal"`
	ICreatedAt     pgtype.Timestamptz `json:"i_created_at"`
}

// N+1 문제 해결: 주문 + 아이템을 한 번에 조회
func (q *Queries) ListOrdersWithItemsByUserID(ctx context.Context, arg ListOrdersWithItemsByUserIDParams) ([]ListOrdersWithItemsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, listOrdersWithItemsByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrdersWithItemsByUserIDRow
	for rows.Next() {
		var i ListOrdersWithItemsByUserIDRow
		if err := rows.Scan(
			&i.OID,
			&i.OUserID,
			&i.OTotalAmount,
			&i.OStatus,
			&i.ORecipientName,
			&i.OPhone,
			&i.OAddress,
			&i.OAddressDetail,
			&i.OPostalCode,
			&i.OCancelledAt,
			&i.OCancelReason,
			&i.OCreatedAt,
			&i.OUpdatedAt,
			&i.IID,
			&i.IProductID,
			&i.IDealID,
			&i.IProductName,
			&i.IQuantity,
			&i.IUnitPrice,
			&i.ISubtotal,
			&i.ICreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersWithItemsByUserIDAndStatus = `-- name: ListOrdersWithItemsByUserIDAndStatus :many
SELECT
    o.id AS o_id,
    o.user_id AS o_user_id,
    o.total_amount AS o_total_amount,
    o.status AS o_status,
    o.recipient_name AS o_recipient_name,
    o.phone AS o_phone,
    o.address AS o_address,
    o.address_detail AS o_address_detail,
    o.postal_code AS o_postal_code,
    o.cancelled_at AS o_cancelled_at,
    o.cancel_reason AS o_cancel_reason,
    o.created_at AS o_created_at,
    o.updated_at AS o_updated_at,
    i.id AS i_id,
    i.product_id AS i_product_id,
    i.deal_id AS i_deal_id,
    i.product_name AS i_product_name,
    i.quantity AS i_quantity,
    i.unit_price AS i_unit_price,
    i.subtotal AS i_subtotal,
    i.created_at AS i_created_at
FROM orders.orders o
LEFT JOIN orders.order_items i ON o.id = i.order_id
WHERE o.user_id = $1 AND o.status = $2
ORDER BY o.created_at DESC, i.created_at
LIMIT $3 OFFSET $4
`

type ListOrdersWithItemsByUserIDAndStatusParams struct {
	UserID pgtype.UUID       `json:"user_id"`
	Status OrdersOrderStatus `json:"status"`
	Limit  int32             `json:"limit"`
	Offset int32             `json:"offset"`
}

type ListOrdersWithItemsByUserIDAndStatusRow struct {
	OID            pgtype.UUID        `json:"o_id"`
	OUserID        pgtype.UUID        `json:"o_user_id"`
	OTotalAmount   int32              `json:"o_total_amount"`
	OStatus        OrdersOrderStatus  `json:"o_status"`
	ORecipientName pgtype.Text        `json:"o_recipient_name"`
	OPhone         pgtype.Text        `json:"o_phone"`
	OAddress       pgtype.Text        `json:"o_address"`
	OAddressDetail pgtype.Text        `json:"o_address_detail"`
	OPostalCode    pgtype.Text        `json:"o_postal_code"`
	OCancelledAt   pgtype.Timestamptz `json:"o_cancelled_at"`
	OCancelReason  pgtype.Text        `json:"o_cancel_reason"`
	OCreatedAt     pgtype.Timestamptz `json:"o_created_at"`
	OUpdatedAt     pgtype.Timestamptz `json:"o_updated_at"`
	IID            pgtype.UUID        `json:"i_id"`
	IProductID     pgtype.UUID        `json:"i_product_id"`
	IDealID        pgtype.UUID        `json:"i_deal_id"`
	IProductName   pgtype.Text        `json:"i_product_name"`
	IQuantity      pgtype.Int4        `json:"i_quantity"`
	IUnitPrice     pgtype.Int4        `json:"i_unit_price"`
	ISubtotal      pgtype.Int4        `json:"i_subtotal"`
	ICreatedAt     pgtype.Timestamptz `json:"i_created_at"`
}

func (q *Queries) ListOrdersWithItemsByUserIDAndStatus(ctx context.Context, arg ListOrdersWithItemsByUserIDAndStatusParams) ([]ListOrdersWithItemsByUserIDAndStatusRow, error) {
	rows, err := q.db.Query(ctx, listOrdersWithItemsByUserIDAndStatus,
		arg.UserID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrdersWithItemsByUserIDAndStatusRow
	for rows.Next() {
		var i ListOrdersWithItemsByUserIDAndStatusRow
		if err := rows.Scan(
			&i.OID,
			&i.OUserID,
			&i.OTotalAmount,
			&i.OStatus,
			&i.ORecipientName,
			&i.OPhone,
			&i.OAddress,
			&i.OAddressDetail,
			&i.OPostalCode,
			&i.OCancelledAt,
			&i.OCancelReason,
			&i.OCreatedAt,
			&i.OUpdatedAt,
			&i.IID,
			&i.IProductID,
			&i.IDealID,
			&i.IProductName,
			&i.IQuantity,
			&i.IUnitPrice,
			&i.ISubtotal,
			&i.ICreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrderStatus = `-- name: UpdateOrderStatus :one
UPDATE orders.orders
SET status = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, total_amount, status, recipient_name, phone, address, address_detail, postal_code, cancelled_at, cancel_reason, created_at, updated_at
`

type UpdateOrderStatusParams struct {
	ID     pgtype.UUID       `json:"id"`
	Status OrdersOrderStatus `json:"status"`
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) (OrdersOrder, error) {
	row := q.db.QueryRow(ctx, updateOrderStatus, arg.ID, arg.Status)
	var i OrdersOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TotalAmount,
		&i.Status,
		&i.RecipientName,
		&i.Phone,
		&i.Address,
		&i.AddressDetail,
		&i.PostalCode,
		&i.CancelledAt,
		&i.CancelReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
