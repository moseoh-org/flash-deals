# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: query.sql
import dataclasses
import datetime
from typing import Any, AsyncIterator, Optional
import uuid

import sqlalchemy
import sqlalchemy.ext.asyncio

from src.generated import models


CANCEL_ORDER = """-- name: cancel_order \\:one
UPDATE orders.orders
SET status = 'cancelled', cancelled_at = NOW(), cancel_reason = :p2, updated_at = NOW()
WHERE id = :p1
RETURNING id, user_id, total_amount, status, recipient_name, phone, address, address_detail, postal_code, cancelled_at, cancel_reason, created_at, updated_at
"""


COUNT_ORDERS_BY_USER_ID = """-- name: count_orders_by_user_id \\:one
SELECT COUNT(*) FROM orders.orders WHERE user_id = :p1
"""


COUNT_ORDERS_BY_USER_ID_AND_STATUS = """-- name: count_orders_by_user_id_and_status \\:one
SELECT COUNT(*) FROM orders.orders WHERE user_id = :p1 AND status = :p2
"""


CREATE_ORDER = """-- name: create_order \\:one

INSERT INTO orders.orders (user_id, total_amount, status, recipient_name, phone, address, address_detail, postal_code)
VALUES (:p1, :p2, :p3, :p4, :p5, :p6, :p7, :p8)
RETURNING id, user_id, total_amount, status, recipient_name, phone, address, address_detail, postal_code, cancelled_at, cancel_reason, created_at, updated_at
"""


@dataclasses.dataclass()
class CreateOrderParams:
    user_id: uuid.UUID
    total_amount: int
    status: Any
    recipient_name: Optional[str]
    phone: Optional[str]
    address: Optional[str]
    address_detail: Optional[str]
    postal_code: Optional[str]


CREATE_ORDER_ITEM = """-- name: create_order_item \\:one
INSERT INTO orders.order_items (order_id, product_id, deal_id, product_name, quantity, unit_price, subtotal)
VALUES (:p1, :p2, :p3, :p4, :p5, :p6, :p7)
RETURNING id, order_id, product_id, deal_id, product_name, quantity, unit_price, subtotal, created_at
"""


@dataclasses.dataclass()
class CreateOrderItemParams:
    order_id: uuid.UUID
    product_id: uuid.UUID
    deal_id: Optional[uuid.UUID]
    product_name: str
    quantity: int
    unit_price: int
    subtotal: int


GET_ORDER_BY_ID = """-- name: get_order_by_id \\:one
SELECT id, user_id, total_amount, status, recipient_name, phone, address, address_detail, postal_code, cancelled_at, cancel_reason, created_at, updated_at
FROM orders.orders
WHERE id = :p1
"""


GET_ORDER_FOR_UPDATE = """-- name: get_order_for_update \\:one
SELECT id, user_id, status FROM orders.orders WHERE id = :p1 FOR UPDATE
"""


@dataclasses.dataclass()
class GetOrderForUpdateRow:
    id: uuid.UUID
    user_id: uuid.UUID
    status: Any


GET_ORDER_ITEMS_BY_ORDER_ID = """-- name: get_order_items_by_order_id \\:many
SELECT id, order_id, product_id, deal_id, product_name, quantity, unit_price, subtotal, created_at
FROM orders.order_items
WHERE order_id = :p1
ORDER BY created_at
"""


LIST_ORDERS_BY_USER_ID = """-- name: list_orders_by_user_id \\:many
SELECT id, user_id, total_amount, status, recipient_name, phone, address, address_detail, postal_code, cancelled_at, cancel_reason, created_at, updated_at
FROM orders.orders
WHERE user_id = :p1
ORDER BY created_at DESC
LIMIT :p2 OFFSET :p3
"""


LIST_ORDERS_BY_USER_ID_AND_STATUS = """-- name: list_orders_by_user_id_and_status \\:many
SELECT id, user_id, total_amount, status, recipient_name, phone, address, address_detail, postal_code, cancelled_at, cancel_reason, created_at, updated_at
FROM orders.orders
WHERE user_id = :p1 AND status = :p2
ORDER BY created_at DESC
LIMIT :p3 OFFSET :p4
"""


LIST_ORDERS_WITH_ITEMS_BY_USER_ID = """-- name: list_orders_with_items_by_user_id \\:many
SELECT
    o.id AS o_id,
    o.user_id AS o_user_id,
    o.total_amount AS o_total_amount,
    o.status AS o_status,
    o.recipient_name AS o_recipient_name,
    o.phone AS o_phone,
    o.address AS o_address,
    o.address_detail AS o_address_detail,
    o.postal_code AS o_postal_code,
    o.cancelled_at AS o_cancelled_at,
    o.cancel_reason AS o_cancel_reason,
    o.created_at AS o_created_at,
    o.updated_at AS o_updated_at,
    i.id AS i_id,
    i.product_id AS i_product_id,
    i.deal_id AS i_deal_id,
    i.product_name AS i_product_name,
    i.quantity AS i_quantity,
    i.unit_price AS i_unit_price,
    i.subtotal AS i_subtotal,
    i.created_at AS i_created_at
FROM orders.orders o
LEFT JOIN orders.order_items i ON o.id = i.order_id
WHERE o.user_id = :p1
ORDER BY o.created_at DESC, i.created_at
LIMIT :p2 OFFSET :p3
"""


@dataclasses.dataclass()
class ListOrdersWithItemsByUserIDRow:
    o_id: uuid.UUID
    o_user_id: uuid.UUID
    o_total_amount: int
    o_status: Any
    o_recipient_name: Optional[str]
    o_phone: Optional[str]
    o_address: Optional[str]
    o_address_detail: Optional[str]
    o_postal_code: Optional[str]
    o_cancelled_at: Optional[datetime.datetime]
    o_cancel_reason: Optional[str]
    o_created_at: datetime.datetime
    o_updated_at: datetime.datetime
    i_id: Optional[uuid.UUID]
    i_product_id: Optional[uuid.UUID]
    i_deal_id: Optional[uuid.UUID]
    i_product_name: Optional[str]
    i_quantity: Optional[int]
    i_unit_price: Optional[int]
    i_subtotal: Optional[int]
    i_created_at: Optional[datetime.datetime]


LIST_ORDERS_WITH_ITEMS_BY_USER_ID_AND_STATUS = """-- name: list_orders_with_items_by_user_id_and_status \\:many
SELECT
    o.id AS o_id,
    o.user_id AS o_user_id,
    o.total_amount AS o_total_amount,
    o.status AS o_status,
    o.recipient_name AS o_recipient_name,
    o.phone AS o_phone,
    o.address AS o_address,
    o.address_detail AS o_address_detail,
    o.postal_code AS o_postal_code,
    o.cancelled_at AS o_cancelled_at,
    o.cancel_reason AS o_cancel_reason,
    o.created_at AS o_created_at,
    o.updated_at AS o_updated_at,
    i.id AS i_id,
    i.product_id AS i_product_id,
    i.deal_id AS i_deal_id,
    i.product_name AS i_product_name,
    i.quantity AS i_quantity,
    i.unit_price AS i_unit_price,
    i.subtotal AS i_subtotal,
    i.created_at AS i_created_at
FROM orders.orders o
LEFT JOIN orders.order_items i ON o.id = i.order_id
WHERE o.user_id = :p1 AND o.status = :p2
ORDER BY o.created_at DESC, i.created_at
LIMIT :p3 OFFSET :p4
"""


@dataclasses.dataclass()
class ListOrdersWithItemsByUserIDAndStatusRow:
    o_id: uuid.UUID
    o_user_id: uuid.UUID
    o_total_amount: int
    o_status: Any
    o_recipient_name: Optional[str]
    o_phone: Optional[str]
    o_address: Optional[str]
    o_address_detail: Optional[str]
    o_postal_code: Optional[str]
    o_cancelled_at: Optional[datetime.datetime]
    o_cancel_reason: Optional[str]
    o_created_at: datetime.datetime
    o_updated_at: datetime.datetime
    i_id: Optional[uuid.UUID]
    i_product_id: Optional[uuid.UUID]
    i_deal_id: Optional[uuid.UUID]
    i_product_name: Optional[str]
    i_quantity: Optional[int]
    i_unit_price: Optional[int]
    i_subtotal: Optional[int]
    i_created_at: Optional[datetime.datetime]


UPDATE_ORDER_STATUS = """-- name: update_order_status \\:one
UPDATE orders.orders
SET status = :p2, updated_at = NOW()
WHERE id = :p1
RETURNING id, user_id, total_amount, status, recipient_name, phone, address, address_detail, postal_code, cancelled_at, cancel_reason, created_at, updated_at
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def cancel_order(self, *, id: uuid.UUID, cancel_reason: Optional[str]) -> Optional[models.OrdersOrder]:
        row = (await self._conn.execute(sqlalchemy.text(CANCEL_ORDER), {"p1": id, "p2": cancel_reason})).first()
        if row is None:
            return None
        return models.OrdersOrder(
            id=row[0],
            user_id=row[1],
            total_amount=row[2],
            status=row[3],
            recipient_name=row[4],
            phone=row[5],
            address=row[6],
            address_detail=row[7],
            postal_code=row[8],
            cancelled_at=row[9],
            cancel_reason=row[10],
            created_at=row[11],
            updated_at=row[12],
        )

    async def count_orders_by_user_id(self, *, user_id: uuid.UUID) -> Optional[int]:
        row = (await self._conn.execute(sqlalchemy.text(COUNT_ORDERS_BY_USER_ID), {"p1": user_id})).first()
        if row is None:
            return None
        return row[0]

    async def count_orders_by_user_id_and_status(self, *, user_id: uuid.UUID, status: Any) -> Optional[int]:
        row = (await self._conn.execute(sqlalchemy.text(COUNT_ORDERS_BY_USER_ID_AND_STATUS), {"p1": user_id, "p2": status})).first()
        if row is None:
            return None
        return row[0]

    async def create_order(self, arg: CreateOrderParams) -> Optional[models.OrdersOrder]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_ORDER), {
            "p1": arg.user_id,
            "p2": arg.total_amount,
            "p3": arg.status,
            "p4": arg.recipient_name,
            "p5": arg.phone,
            "p6": arg.address,
            "p7": arg.address_detail,
            "p8": arg.postal_code,
        })).first()
        if row is None:
            return None
        return models.OrdersOrder(
            id=row[0],
            user_id=row[1],
            total_amount=row[2],
            status=row[3],
            recipient_name=row[4],
            phone=row[5],
            address=row[6],
            address_detail=row[7],
            postal_code=row[8],
            cancelled_at=row[9],
            cancel_reason=row[10],
            created_at=row[11],
            updated_at=row[12],
        )

    async def create_order_item(self, arg: CreateOrderItemParams) -> Optional[models.OrdersOrderItem]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_ORDER_ITEM), {
            "p1": arg.order_id,
            "p2": arg.product_id,
            "p3": arg.deal_id,
            "p4": arg.product_name,
            "p5": arg.quantity,
            "p6": arg.unit_price,
            "p7": arg.subtotal,
        })).first()
        if row is None:
            return None
        return models.OrdersOrderItem(
            id=row[0],
            order_id=row[1],
            product_id=row[2],
            deal_id=row[3],
            product_name=row[4],
            quantity=row[5],
            unit_price=row[6],
            subtotal=row[7],
            created_at=row[8],
        )

    async def get_order_by_id(self, *, id: uuid.UUID) -> Optional[models.OrdersOrder]:
        row = (await self._conn.execute(sqlalchemy.text(GET_ORDER_BY_ID), {"p1": id})).first()
        if row is None:
            return None
        return models.OrdersOrder(
            id=row[0],
            user_id=row[1],
            total_amount=row[2],
            status=row[3],
            recipient_name=row[4],
            phone=row[5],
            address=row[6],
            address_detail=row[7],
            postal_code=row[8],
            cancelled_at=row[9],
            cancel_reason=row[10],
            created_at=row[11],
            updated_at=row[12],
        )

    async def get_order_for_update(self, *, id: uuid.UUID) -> Optional[GetOrderForUpdateRow]:
        row = (await self._conn.execute(sqlalchemy.text(GET_ORDER_FOR_UPDATE), {"p1": id})).first()
        if row is None:
            return None
        return GetOrderForUpdateRow(
            id=row[0],
            user_id=row[1],
            status=row[2],
        )

    async def get_order_items_by_order_id(self, *, order_id: uuid.UUID) -> AsyncIterator[models.OrdersOrderItem]:
        result = await self._conn.stream(sqlalchemy.text(GET_ORDER_ITEMS_BY_ORDER_ID), {"p1": order_id})
        async for row in result:
            yield models.OrdersOrderItem(
                id=row[0],
                order_id=row[1],
                product_id=row[2],
                deal_id=row[3],
                product_name=row[4],
                quantity=row[5],
                unit_price=row[6],
                subtotal=row[7],
                created_at=row[8],
            )

    async def list_orders_by_user_id(self, *, user_id: uuid.UUID, limit: int, offset: int) -> AsyncIterator[models.OrdersOrder]:
        result = await self._conn.stream(sqlalchemy.text(LIST_ORDERS_BY_USER_ID), {"p1": user_id, "p2": limit, "p3": offset})
        async for row in result:
            yield models.OrdersOrder(
                id=row[0],
                user_id=row[1],
                total_amount=row[2],
                status=row[3],
                recipient_name=row[4],
                phone=row[5],
                address=row[6],
                address_detail=row[7],
                postal_code=row[8],
                cancelled_at=row[9],
                cancel_reason=row[10],
                created_at=row[11],
                updated_at=row[12],
            )

    async def list_orders_by_user_id_and_status(self, *, user_id: uuid.UUID, status: Any, limit: int, offset: int) -> AsyncIterator[models.OrdersOrder]:
        result = await self._conn.stream(sqlalchemy.text(LIST_ORDERS_BY_USER_ID_AND_STATUS), {
            "p1": user_id,
            "p2": status,
            "p3": limit,
            "p4": offset,
        })
        async for row in result:
            yield models.OrdersOrder(
                id=row[0],
                user_id=row[1],
                total_amount=row[2],
                status=row[3],
                recipient_name=row[4],
                phone=row[5],
                address=row[6],
                address_detail=row[7],
                postal_code=row[8],
                cancelled_at=row[9],
                cancel_reason=row[10],
                created_at=row[11],
                updated_at=row[12],
            )

    async def list_orders_with_items_by_user_id(self, *, user_id: uuid.UUID, limit: int, offset: int) -> AsyncIterator[ListOrdersWithItemsByUserIDRow]:
        result = await self._conn.stream(sqlalchemy.text(LIST_ORDERS_WITH_ITEMS_BY_USER_ID), {"p1": user_id, "p2": limit, "p3": offset})
        async for row in result:
            yield ListOrdersWithItemsByUserIDRow(
                o_id=row[0],
                o_user_id=row[1],
                o_total_amount=row[2],
                o_status=row[3],
                o_recipient_name=row[4],
                o_phone=row[5],
                o_address=row[6],
                o_address_detail=row[7],
                o_postal_code=row[8],
                o_cancelled_at=row[9],
                o_cancel_reason=row[10],
                o_created_at=row[11],
                o_updated_at=row[12],
                i_id=row[13],
                i_product_id=row[14],
                i_deal_id=row[15],
                i_product_name=row[16],
                i_quantity=row[17],
                i_unit_price=row[18],
                i_subtotal=row[19],
                i_created_at=row[20],
            )

    async def list_orders_with_items_by_user_id_and_status(self, *, user_id: uuid.UUID, status: Any, limit: int, offset: int) -> AsyncIterator[ListOrdersWithItemsByUserIDAndStatusRow]:
        result = await self._conn.stream(sqlalchemy.text(LIST_ORDERS_WITH_ITEMS_BY_USER_ID_AND_STATUS), {
            "p1": user_id,
            "p2": status,
            "p3": limit,
            "p4": offset,
        })
        async for row in result:
            yield ListOrdersWithItemsByUserIDAndStatusRow(
                o_id=row[0],
                o_user_id=row[1],
                o_total_amount=row[2],
                o_status=row[3],
                o_recipient_name=row[4],
                o_phone=row[5],
                o_address=row[6],
                o_address_detail=row[7],
                o_postal_code=row[8],
                o_cancelled_at=row[9],
                o_cancel_reason=row[10],
                o_created_at=row[11],
                o_updated_at=row[12],
                i_id=row[13],
                i_product_id=row[14],
                i_deal_id=row[15],
                i_product_name=row[16],
                i_quantity=row[17],
                i_unit_price=row[18],
                i_subtotal=row[19],
                i_created_at=row[20],
            )

    async def update_order_status(self, *, id: uuid.UUID, status: Any) -> Optional[models.OrdersOrder]:
        row = (await self._conn.execute(sqlalchemy.text(UPDATE_ORDER_STATUS), {"p1": id, "p2": status})).first()
        if row is None:
            return None
        return models.OrdersOrder(
            id=row[0],
            user_id=row[1],
            total_amount=row[2],
            status=row[3],
            recipient_name=row[4],
            phone=row[5],
            address=row[6],
            address_detail=row[7],
            postal_code=row[8],
            cancelled_at=row[9],
            cancel_reason=row[10],
            created_at=row[11],
            updated_at=row[12],
        )
