# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: query.sql
import dataclasses
from typing import Any, AsyncIterator, Optional
import uuid

import sqlalchemy
import sqlalchemy.ext.asyncio

from src.generated import models


CANCEL_ORDER = """-- name: cancel_order \\:one
UPDATE orders.orders
SET status = 'cancelled', cancelled_at = NOW(), cancel_reason = :p2, updated_at = NOW()
WHERE id = :p1
RETURNING id, user_id, total_amount, status, recipient_name, phone, address, address_detail, postal_code, cancelled_at, cancel_reason, created_at, updated_at
"""


COUNT_ORDERS_BY_USER_ID = """-- name: count_orders_by_user_id \\:one
SELECT COUNT(*) FROM orders.orders WHERE user_id = :p1
"""


COUNT_ORDERS_BY_USER_ID_AND_STATUS = """-- name: count_orders_by_user_id_and_status \\:one
SELECT COUNT(*) FROM orders.orders WHERE user_id = :p1 AND status = :p2
"""


CREATE_ORDER = """-- name: create_order \\:one

INSERT INTO orders.orders (user_id, total_amount, status, recipient_name, phone, address, address_detail, postal_code)
VALUES (:p1, :p2, :p3, :p4, :p5, :p6, :p7, :p8)
RETURNING id, user_id, total_amount, status, recipient_name, phone, address, address_detail, postal_code, cancelled_at, cancel_reason, created_at, updated_at
"""


@dataclasses.dataclass()
class CreateOrderParams:
    user_id: uuid.UUID
    total_amount: int
    status: Any
    recipient_name: Optional[str]
    phone: Optional[str]
    address: Optional[str]
    address_detail: Optional[str]
    postal_code: Optional[str]


CREATE_ORDER_ITEM = """-- name: create_order_item \\:one
INSERT INTO orders.order_items (order_id, product_id, deal_id, product_name, quantity, unit_price, subtotal)
VALUES (:p1, :p2, :p3, :p4, :p5, :p6, :p7)
RETURNING id, order_id, product_id, deal_id, product_name, quantity, unit_price, subtotal, created_at
"""


@dataclasses.dataclass()
class CreateOrderItemParams:
    order_id: uuid.UUID
    product_id: uuid.UUID
    deal_id: Optional[uuid.UUID]
    product_name: str
    quantity: int
    unit_price: int
    subtotal: int


GET_ORDER_BY_ID = """-- name: get_order_by_id \\:one
SELECT id, user_id, total_amount, status, recipient_name, phone, address, address_detail, postal_code, cancelled_at, cancel_reason, created_at, updated_at
FROM orders.orders
WHERE id = :p1
"""


GET_ORDER_FOR_UPDATE = """-- name: get_order_for_update \\:one
SELECT id, user_id, status FROM orders.orders WHERE id = :p1 FOR UPDATE
"""


@dataclasses.dataclass()
class GetOrderForUpdateRow:
    id: uuid.UUID
    user_id: uuid.UUID
    status: Any


GET_ORDER_ITEMS_BY_ORDER_ID = """-- name: get_order_items_by_order_id \\:many
SELECT id, order_id, product_id, deal_id, product_name, quantity, unit_price, subtotal, created_at
FROM orders.order_items
WHERE order_id = :p1
ORDER BY created_at
"""


LIST_ORDERS_BY_USER_ID = """-- name: list_orders_by_user_id \\:many
SELECT id, user_id, total_amount, status, recipient_name, phone, address, address_detail, postal_code, cancelled_at, cancel_reason, created_at, updated_at
FROM orders.orders
WHERE user_id = :p1
ORDER BY created_at DESC
LIMIT :p2 OFFSET :p3
"""


LIST_ORDERS_BY_USER_ID_AND_STATUS = """-- name: list_orders_by_user_id_and_status \\:many
SELECT id, user_id, total_amount, status, recipient_name, phone, address, address_detail, postal_code, cancelled_at, cancel_reason, created_at, updated_at
FROM orders.orders
WHERE user_id = :p1 AND status = :p2
ORDER BY created_at DESC
LIMIT :p3 OFFSET :p4
"""


UPDATE_ORDER_STATUS = """-- name: update_order_status \\:one
UPDATE orders.orders
SET status = :p2, updated_at = NOW()
WHERE id = :p1
RETURNING id, user_id, total_amount, status, recipient_name, phone, address, address_detail, postal_code, cancelled_at, cancel_reason, created_at, updated_at
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def cancel_order(self, *, id: uuid.UUID, cancel_reason: Optional[str]) -> Optional[models.OrdersOrder]:
        row = (await self._conn.execute(sqlalchemy.text(CANCEL_ORDER), {"p1": id, "p2": cancel_reason})).first()
        if row is None:
            return None
        return models.OrdersOrder(
            id=row[0],
            user_id=row[1],
            total_amount=row[2],
            status=row[3],
            recipient_name=row[4],
            phone=row[5],
            address=row[6],
            address_detail=row[7],
            postal_code=row[8],
            cancelled_at=row[9],
            cancel_reason=row[10],
            created_at=row[11],
            updated_at=row[12],
        )

    async def count_orders_by_user_id(self, *, user_id: uuid.UUID) -> Optional[int]:
        row = (await self._conn.execute(sqlalchemy.text(COUNT_ORDERS_BY_USER_ID), {"p1": user_id})).first()
        if row is None:
            return None
        return row[0]

    async def count_orders_by_user_id_and_status(self, *, user_id: uuid.UUID, status: Any) -> Optional[int]:
        row = (await self._conn.execute(sqlalchemy.text(COUNT_ORDERS_BY_USER_ID_AND_STATUS), {"p1": user_id, "p2": status})).first()
        if row is None:
            return None
        return row[0]

    async def create_order(self, arg: CreateOrderParams) -> Optional[models.OrdersOrder]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_ORDER), {
            "p1": arg.user_id,
            "p2": arg.total_amount,
            "p3": arg.status,
            "p4": arg.recipient_name,
            "p5": arg.phone,
            "p6": arg.address,
            "p7": arg.address_detail,
            "p8": arg.postal_code,
        })).first()
        if row is None:
            return None
        return models.OrdersOrder(
            id=row[0],
            user_id=row[1],
            total_amount=row[2],
            status=row[3],
            recipient_name=row[4],
            phone=row[5],
            address=row[6],
            address_detail=row[7],
            postal_code=row[8],
            cancelled_at=row[9],
            cancel_reason=row[10],
            created_at=row[11],
            updated_at=row[12],
        )

    async def create_order_item(self, arg: CreateOrderItemParams) -> Optional[models.OrdersOrderItem]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_ORDER_ITEM), {
            "p1": arg.order_id,
            "p2": arg.product_id,
            "p3": arg.deal_id,
            "p4": arg.product_name,
            "p5": arg.quantity,
            "p6": arg.unit_price,
            "p7": arg.subtotal,
        })).first()
        if row is None:
            return None
        return models.OrdersOrderItem(
            id=row[0],
            order_id=row[1],
            product_id=row[2],
            deal_id=row[3],
            product_name=row[4],
            quantity=row[5],
            unit_price=row[6],
            subtotal=row[7],
            created_at=row[8],
        )

    async def get_order_by_id(self, *, id: uuid.UUID) -> Optional[models.OrdersOrder]:
        row = (await self._conn.execute(sqlalchemy.text(GET_ORDER_BY_ID), {"p1": id})).first()
        if row is None:
            return None
        return models.OrdersOrder(
            id=row[0],
            user_id=row[1],
            total_amount=row[2],
            status=row[3],
            recipient_name=row[4],
            phone=row[5],
            address=row[6],
            address_detail=row[7],
            postal_code=row[8],
            cancelled_at=row[9],
            cancel_reason=row[10],
            created_at=row[11],
            updated_at=row[12],
        )

    async def get_order_for_update(self, *, id: uuid.UUID) -> Optional[GetOrderForUpdateRow]:
        row = (await self._conn.execute(sqlalchemy.text(GET_ORDER_FOR_UPDATE), {"p1": id})).first()
        if row is None:
            return None
        return GetOrderForUpdateRow(
            id=row[0],
            user_id=row[1],
            status=row[2],
        )

    async def get_order_items_by_order_id(self, *, order_id: uuid.UUID) -> AsyncIterator[models.OrdersOrderItem]:
        result = await self._conn.stream(sqlalchemy.text(GET_ORDER_ITEMS_BY_ORDER_ID), {"p1": order_id})
        async for row in result:
            yield models.OrdersOrderItem(
                id=row[0],
                order_id=row[1],
                product_id=row[2],
                deal_id=row[3],
                product_name=row[4],
                quantity=row[5],
                unit_price=row[6],
                subtotal=row[7],
                created_at=row[8],
            )

    async def list_orders_by_user_id(self, *, user_id: uuid.UUID, limit: int, offset: int) -> AsyncIterator[models.OrdersOrder]:
        result = await self._conn.stream(sqlalchemy.text(LIST_ORDERS_BY_USER_ID), {"p1": user_id, "p2": limit, "p3": offset})
        async for row in result:
            yield models.OrdersOrder(
                id=row[0],
                user_id=row[1],
                total_amount=row[2],
                status=row[3],
                recipient_name=row[4],
                phone=row[5],
                address=row[6],
                address_detail=row[7],
                postal_code=row[8],
                cancelled_at=row[9],
                cancel_reason=row[10],
                created_at=row[11],
                updated_at=row[12],
            )

    async def list_orders_by_user_id_and_status(self, *, user_id: uuid.UUID, status: Any, limit: int, offset: int) -> AsyncIterator[models.OrdersOrder]:
        result = await self._conn.stream(sqlalchemy.text(LIST_ORDERS_BY_USER_ID_AND_STATUS), {
            "p1": user_id,
            "p2": status,
            "p3": limit,
            "p4": offset,
        })
        async for row in result:
            yield models.OrdersOrder(
                id=row[0],
                user_id=row[1],
                total_amount=row[2],
                status=row[3],
                recipient_name=row[4],
                phone=row[5],
                address=row[6],
                address_detail=row[7],
                postal_code=row[8],
                cancelled_at=row[9],
                cancel_reason=row[10],
                created_at=row[11],
                updated_at=row[12],
            )

    async def update_order_status(self, *, id: uuid.UUID, status: Any) -> Optional[models.OrdersOrder]:
        row = (await self._conn.execute(sqlalchemy.text(UPDATE_ORDER_STATUS), {"p1": id, "p2": status})).first()
        if row is None:
            return None
        return models.OrdersOrder(
            id=row[0],
            user_id=row[1],
            total_amount=row[2],
            status=row[3],
            recipient_name=row[4],
            phone=row[5],
            address=row[6],
            address_detail=row[7],
            postal_code=row[8],
            cancelled_at=row[9],
            cancel_reason=row[10],
            created_at=row[11],
            updated_at=row[12],
        )
