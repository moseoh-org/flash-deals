# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: query.sql
import dataclasses
import datetime
from typing import AsyncIterator, Optional
import uuid

import sqlalchemy
import sqlalchemy.ext.asyncio

from src.generated import models


COUNT_ACTIVE_DEALS = """-- name: count_active_deals \\:one
SELECT COUNT(*) FROM product.deals
WHERE starts_at <= :p1 AND ends_at >= :p1 AND remaining_stock > 0
"""


COUNT_PRODUCTS = """-- name: count_products \\:one
SELECT COUNT(*) FROM product.products
"""


COUNT_PRODUCTS_BY_CATEGORY = """-- name: count_products_by_category \\:one
SELECT COUNT(*) FROM product.products WHERE category = :p1
"""


CREATE_DEAL = """-- name: create_deal \\:one

INSERT INTO product.deals (product_id, deal_price, deal_stock, remaining_stock, starts_at, ends_at)
VALUES (:p1, :p2, :p3, :p4, :p5, :p6)
RETURNING id, product_id, deal_price, deal_stock, remaining_stock, starts_at, ends_at, created_at
"""


@dataclasses.dataclass()
class CreateDealParams:
    product_id: uuid.UUID
    deal_price: int
    deal_stock: int
    remaining_stock: int
    starts_at: datetime.datetime
    ends_at: datetime.datetime


CREATE_PRODUCT = """-- name: create_product \\:one

INSERT INTO product.products (name, description, price, stock, category, image_url)
VALUES (:p1, :p2, :p3, :p4, :p5, :p6)
RETURNING id, name, description, price, stock, category, image_url, created_at, updated_at
"""


@dataclasses.dataclass()
class CreateProductParams:
    name: str
    description: Optional[str]
    price: int
    stock: int
    category: Optional[str]
    image_url: Optional[str]


GET_DEAL_BY_ID = """-- name: get_deal_by_id \\:one
SELECT d.id, d.product_id, d.deal_price, d.deal_stock, d.remaining_stock,
       d.starts_at, d.ends_at, d.created_at,
       p.id as p_id, p.name as p_name, p.description as p_description,
       p.price as p_price, p.stock as p_stock, p.category as p_category,
       p.image_url as p_image_url, p.created_at as p_created_at, p.updated_at as p_updated_at
FROM product.deals d
JOIN product.products p ON d.product_id = p.id
WHERE d.id = :p1
"""


@dataclasses.dataclass()
class GetDealByIDRow:
    id: uuid.UUID
    product_id: uuid.UUID
    deal_price: int
    deal_stock: int
    remaining_stock: int
    starts_at: datetime.datetime
    ends_at: datetime.datetime
    created_at: datetime.datetime
    p_id: uuid.UUID
    p_name: str
    p_description: Optional[str]
    p_price: int
    p_stock: int
    p_category: Optional[str]
    p_image_url: Optional[str]
    p_created_at: datetime.datetime
    p_updated_at: datetime.datetime


GET_PRODUCT_BY_ID = """-- name: get_product_by_id \\:one
SELECT id, name, description, price, stock, category, image_url, created_at, updated_at
FROM product.products
WHERE id = :p1
"""


GET_STOCK_FOR_UPDATE = """-- name: get_stock_for_update \\:one
SELECT id, stock FROM product.products WHERE id = :p1 FOR UPDATE
"""


@dataclasses.dataclass()
class GetStockForUpdateRow:
    id: uuid.UUID
    stock: int


LIST_ACTIVE_DEALS = """-- name: list_active_deals \\:many
SELECT d.id, d.product_id, d.deal_price, d.deal_stock, d.remaining_stock,
       d.starts_at, d.ends_at, d.created_at,
       p.id as p_id, p.name as p_name, p.description as p_description,
       p.price as p_price, p.stock as p_stock, p.category as p_category,
       p.image_url as p_image_url, p.created_at as p_created_at, p.updated_at as p_updated_at
FROM product.deals d
JOIN product.products p ON d.product_id = p.id
WHERE d.starts_at <= :p1 AND d.ends_at >= :p1 AND d.remaining_stock > 0
ORDER BY d.starts_at DESC
LIMIT :p2 OFFSET :p3
"""


@dataclasses.dataclass()
class ListActiveDealsRow:
    id: uuid.UUID
    product_id: uuid.UUID
    deal_price: int
    deal_stock: int
    remaining_stock: int
    starts_at: datetime.datetime
    ends_at: datetime.datetime
    created_at: datetime.datetime
    p_id: uuid.UUID
    p_name: str
    p_description: Optional[str]
    p_price: int
    p_stock: int
    p_category: Optional[str]
    p_image_url: Optional[str]
    p_created_at: datetime.datetime
    p_updated_at: datetime.datetime


LIST_PRODUCTS = """-- name: list_products \\:many
SELECT id, name, description, price, stock, category, image_url, created_at, updated_at
FROM product.products
ORDER BY created_at DESC
LIMIT :p1 OFFSET :p2
"""


LIST_PRODUCTS_BY_CATEGORY = """-- name: list_products_by_category \\:many
SELECT id, name, description, price, stock, category, image_url, created_at, updated_at
FROM product.products
WHERE category = :p1
ORDER BY created_at DESC
LIMIT :p2 OFFSET :p3
"""


UPDATE_PRODUCT = """-- name: update_product \\:one
UPDATE product.products
SET name = COALESCE(:p2, name),
    description = COALESCE(:p3, description),
    price = COALESCE(:p4, price),
    category = COALESCE(:p5, category),
    image_url = COALESCE(:p6, image_url),
    updated_at = NOW()
WHERE id = :p1
RETURNING id, name, description, price, stock, category, image_url, created_at, updated_at
"""


@dataclasses.dataclass()
class UpdateProductParams:
    id: uuid.UUID
    name: str
    description: Optional[str]
    price: int
    category: Optional[str]
    image_url: Optional[str]


UPDATE_STOCK = """-- name: update_stock \\:one
UPDATE product.products
SET stock = :p2, updated_at = NOW()
WHERE id = :p1
RETURNING id, stock, updated_at
"""


@dataclasses.dataclass()
class UpdateStockRow:
    id: uuid.UUID
    stock: int
    updated_at: datetime.datetime


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def count_active_deals(self, *, starts_at: datetime.datetime) -> Optional[int]:
        row = (await self._conn.execute(sqlalchemy.text(COUNT_ACTIVE_DEALS), {"p1": starts_at})).first()
        if row is None:
            return None
        return row[0]

    async def count_products(self) -> Optional[int]:
        row = (await self._conn.execute(sqlalchemy.text(COUNT_PRODUCTS))).first()
        if row is None:
            return None
        return row[0]

    async def count_products_by_category(self, *, category: Optional[str]) -> Optional[int]:
        row = (await self._conn.execute(sqlalchemy.text(COUNT_PRODUCTS_BY_CATEGORY), {"p1": category})).first()
        if row is None:
            return None
        return row[0]

    async def create_deal(self, arg: CreateDealParams) -> Optional[models.ProductDeal]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_DEAL), {
            "p1": arg.product_id,
            "p2": arg.deal_price,
            "p3": arg.deal_stock,
            "p4": arg.remaining_stock,
            "p5": arg.starts_at,
            "p6": arg.ends_at,
        })).first()
        if row is None:
            return None
        return models.ProductDeal(
            id=row[0],
            product_id=row[1],
            deal_price=row[2],
            deal_stock=row[3],
            remaining_stock=row[4],
            starts_at=row[5],
            ends_at=row[6],
            created_at=row[7],
        )

    async def create_product(self, arg: CreateProductParams) -> Optional[models.ProductProduct]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_PRODUCT), {
            "p1": arg.name,
            "p2": arg.description,
            "p3": arg.price,
            "p4": arg.stock,
            "p5": arg.category,
            "p6": arg.image_url,
        })).first()
        if row is None:
            return None
        return models.ProductProduct(
            id=row[0],
            name=row[1],
            description=row[2],
            price=row[3],
            stock=row[4],
            category=row[5],
            image_url=row[6],
            created_at=row[7],
            updated_at=row[8],
        )

    async def get_deal_by_id(self, *, id: uuid.UUID) -> Optional[GetDealByIDRow]:
        row = (await self._conn.execute(sqlalchemy.text(GET_DEAL_BY_ID), {"p1": id})).first()
        if row is None:
            return None
        return GetDealByIDRow(
            id=row[0],
            product_id=row[1],
            deal_price=row[2],
            deal_stock=row[3],
            remaining_stock=row[4],
            starts_at=row[5],
            ends_at=row[6],
            created_at=row[7],
            p_id=row[8],
            p_name=row[9],
            p_description=row[10],
            p_price=row[11],
            p_stock=row[12],
            p_category=row[13],
            p_image_url=row[14],
            p_created_at=row[15],
            p_updated_at=row[16],
        )

    async def get_product_by_id(self, *, id: uuid.UUID) -> Optional[models.ProductProduct]:
        row = (await self._conn.execute(sqlalchemy.text(GET_PRODUCT_BY_ID), {"p1": id})).first()
        if row is None:
            return None
        return models.ProductProduct(
            id=row[0],
            name=row[1],
            description=row[2],
            price=row[3],
            stock=row[4],
            category=row[5],
            image_url=row[6],
            created_at=row[7],
            updated_at=row[8],
        )

    async def get_stock_for_update(self, *, id: uuid.UUID) -> Optional[GetStockForUpdateRow]:
        row = (await self._conn.execute(sqlalchemy.text(GET_STOCK_FOR_UPDATE), {"p1": id})).first()
        if row is None:
            return None
        return GetStockForUpdateRow(
            id=row[0],
            stock=row[1],
        )

    async def list_active_deals(self, *, starts_at: datetime.datetime, limit: int, offset: int) -> AsyncIterator[ListActiveDealsRow]:
        result = await self._conn.stream(sqlalchemy.text(LIST_ACTIVE_DEALS), {"p1": starts_at, "p2": limit, "p3": offset})
        async for row in result:
            yield ListActiveDealsRow(
                id=row[0],
                product_id=row[1],
                deal_price=row[2],
                deal_stock=row[3],
                remaining_stock=row[4],
                starts_at=row[5],
                ends_at=row[6],
                created_at=row[7],
                p_id=row[8],
                p_name=row[9],
                p_description=row[10],
                p_price=row[11],
                p_stock=row[12],
                p_category=row[13],
                p_image_url=row[14],
                p_created_at=row[15],
                p_updated_at=row[16],
            )

    async def list_products(self, *, limit: int, offset: int) -> AsyncIterator[models.ProductProduct]:
        result = await self._conn.stream(sqlalchemy.text(LIST_PRODUCTS), {"p1": limit, "p2": offset})
        async for row in result:
            yield models.ProductProduct(
                id=row[0],
                name=row[1],
                description=row[2],
                price=row[3],
                stock=row[4],
                category=row[5],
                image_url=row[6],
                created_at=row[7],
                updated_at=row[8],
            )

    async def list_products_by_category(self, *, category: Optional[str], limit: int, offset: int) -> AsyncIterator[models.ProductProduct]:
        result = await self._conn.stream(sqlalchemy.text(LIST_PRODUCTS_BY_CATEGORY), {"p1": category, "p2": limit, "p3": offset})
        async for row in result:
            yield models.ProductProduct(
                id=row[0],
                name=row[1],
                description=row[2],
                price=row[3],
                stock=row[4],
                category=row[5],
                image_url=row[6],
                created_at=row[7],
                updated_at=row[8],
            )

    async def update_product(self, arg: UpdateProductParams) -> Optional[models.ProductProduct]:
        row = (await self._conn.execute(sqlalchemy.text(UPDATE_PRODUCT), {
            "p1": arg.id,
            "p2": arg.name,
            "p3": arg.description,
            "p4": arg.price,
            "p5": arg.category,
            "p6": arg.image_url,
        })).first()
        if row is None:
            return None
        return models.ProductProduct(
            id=row[0],
            name=row[1],
            description=row[2],
            price=row[3],
            stock=row[4],
            category=row[5],
            image_url=row[6],
            created_at=row[7],
            updated_at=row[8],
        )

    async def update_stock(self, *, id: uuid.UUID, stock: int) -> Optional[UpdateStockRow]:
        row = (await self._conn.execute(sqlalchemy.text(UPDATE_STOCK), {"p1": id, "p2": stock})).first()
        if row is None:
            return None
        return UpdateStockRow(
            id=row[0],
            stock=row[1],
            updated_at=row[2],
        )
