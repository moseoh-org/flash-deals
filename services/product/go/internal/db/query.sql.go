// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countActiveDeals = `-- name: CountActiveDeals :one
SELECT COUNT(*) FROM product.deals
WHERE starts_at <= $1 AND ends_at >= $1 AND remaining_stock > 0
`

func (q *Queries) CountActiveDeals(ctx context.Context, startsAt pgtype.Timestamptz) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveDeals, startsAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProducts = `-- name: CountProducts :one
SELECT COUNT(*) FROM product.products
`

func (q *Queries) CountProducts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countProducts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProductsByCategory = `-- name: CountProductsByCategory :one
SELECT COUNT(*) FROM product.products WHERE category = $1
`

func (q *Queries) CountProductsByCategory(ctx context.Context, category pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countProductsByCategory, category)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDeal = `-- name: CreateDeal :one

INSERT INTO product.deals (product_id, deal_price, deal_stock, remaining_stock, starts_at, ends_at)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, product_id, deal_price, deal_stock, remaining_stock, starts_at, ends_at, created_at
`

type CreateDealParams struct {
	ProductID      pgtype.UUID        `json:"product_id"`
	DealPrice      int32              `json:"deal_price"`
	DealStock      int32              `json:"deal_stock"`
	RemainingStock int32              `json:"remaining_stock"`
	StartsAt       pgtype.Timestamptz `json:"starts_at"`
	EndsAt         pgtype.Timestamptz `json:"ends_at"`
}

// Deal queries
func (q *Queries) CreateDeal(ctx context.Context, arg CreateDealParams) (ProductDeal, error) {
	row := q.db.QueryRow(ctx, createDeal,
		arg.ProductID,
		arg.DealPrice,
		arg.DealStock,
		arg.RemainingStock,
		arg.StartsAt,
		arg.EndsAt,
	)
	var i ProductDeal
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.DealPrice,
		&i.DealStock,
		&i.RemainingStock,
		&i.StartsAt,
		&i.EndsAt,
		&i.CreatedAt,
	)
	return i, err
}

const createProduct = `-- name: CreateProduct :one

INSERT INTO product.products (name, description, price, stock, category, image_url)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, name, description, price, stock, category, image_url, created_at, updated_at
`

type CreateProductParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Price       int32       `json:"price"`
	Stock       int32       `json:"stock"`
	Category    pgtype.Text `json:"category"`
	ImageUrl    pgtype.Text `json:"image_url"`
}

// Product queries
func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (ProductProduct, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.Stock,
		arg.Category,
		arg.ImageUrl,
	)
	var i ProductProduct
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Stock,
		&i.Category,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDealByID = `-- name: GetDealByID :one
SELECT d.id, d.product_id, d.deal_price, d.deal_stock, d.remaining_stock,
       d.starts_at, d.ends_at, d.created_at,
       p.id as p_id, p.name as p_name, p.description as p_description,
       p.price as p_price, p.stock as p_stock, p.category as p_category,
       p.image_url as p_image_url, p.created_at as p_created_at, p.updated_at as p_updated_at
FROM product.deals d
JOIN product.products p ON d.product_id = p.id
WHERE d.id = $1
`

type GetDealByIDRow struct {
	ID             pgtype.UUID        `json:"id"`
	ProductID      pgtype.UUID        `json:"product_id"`
	DealPrice      int32              `json:"deal_price"`
	DealStock      int32              `json:"deal_stock"`
	RemainingStock int32              `json:"remaining_stock"`
	StartsAt       pgtype.Timestamptz `json:"starts_at"`
	EndsAt         pgtype.Timestamptz `json:"ends_at"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	PID            pgtype.UUID        `json:"p_id"`
	PName          string             `json:"p_name"`
	PDescription   pgtype.Text        `json:"p_description"`
	PPrice         int32              `json:"p_price"`
	PStock         int32              `json:"p_stock"`
	PCategory      pgtype.Text        `json:"p_category"`
	PImageUrl      pgtype.Text        `json:"p_image_url"`
	PCreatedAt     pgtype.Timestamptz `json:"p_created_at"`
	PUpdatedAt     pgtype.Timestamptz `json:"p_updated_at"`
}

func (q *Queries) GetDealByID(ctx context.Context, id pgtype.UUID) (GetDealByIDRow, error) {
	row := q.db.QueryRow(ctx, getDealByID, id)
	var i GetDealByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.DealPrice,
		&i.DealStock,
		&i.RemainingStock,
		&i.StartsAt,
		&i.EndsAt,
		&i.CreatedAt,
		&i.PID,
		&i.PName,
		&i.PDescription,
		&i.PPrice,
		&i.PStock,
		&i.PCategory,
		&i.PImageUrl,
		&i.PCreatedAt,
		&i.PUpdatedAt,
	)
	return i, err
}

const getProductByID = `-- name: GetProductByID :one
SELECT id, name, description, price, stock, category, image_url, created_at, updated_at
FROM product.products
WHERE id = $1
`

func (q *Queries) GetProductByID(ctx context.Context, id pgtype.UUID) (ProductProduct, error) {
	row := q.db.QueryRow(ctx, getProductByID, id)
	var i ProductProduct
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Stock,
		&i.Category,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStockForUpdate = `-- name: GetStockForUpdate :one
SELECT id, stock FROM product.products WHERE id = $1 FOR UPDATE
`

type GetStockForUpdateRow struct {
	ID    pgtype.UUID `json:"id"`
	Stock int32       `json:"stock"`
}

func (q *Queries) GetStockForUpdate(ctx context.Context, id pgtype.UUID) (GetStockForUpdateRow, error) {
	row := q.db.QueryRow(ctx, getStockForUpdate, id)
	var i GetStockForUpdateRow
	err := row.Scan(&i.ID, &i.Stock)
	return i, err
}

const listActiveDeals = `-- name: ListActiveDeals :many
SELECT d.id, d.product_id, d.deal_price, d.deal_stock, d.remaining_stock,
       d.starts_at, d.ends_at, d.created_at,
       p.id as p_id, p.name as p_name, p.description as p_description,
       p.price as p_price, p.stock as p_stock, p.category as p_category,
       p.image_url as p_image_url, p.created_at as p_created_at, p.updated_at as p_updated_at
FROM product.deals d
JOIN product.products p ON d.product_id = p.id
WHERE d.starts_at <= $1 AND d.ends_at >= $1 AND d.remaining_stock > 0
ORDER BY d.starts_at DESC
LIMIT $2 OFFSET $3
`

type ListActiveDealsParams struct {
	StartsAt pgtype.Timestamptz `json:"starts_at"`
	Limit    int32              `json:"limit"`
	Offset   int32              `json:"offset"`
}

type ListActiveDealsRow struct {
	ID             pgtype.UUID        `json:"id"`
	ProductID      pgtype.UUID        `json:"product_id"`
	DealPrice      int32              `json:"deal_price"`
	DealStock      int32              `json:"deal_stock"`
	RemainingStock int32              `json:"remaining_stock"`
	StartsAt       pgtype.Timestamptz `json:"starts_at"`
	EndsAt         pgtype.Timestamptz `json:"ends_at"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	PID            pgtype.UUID        `json:"p_id"`
	PName          string             `json:"p_name"`
	PDescription   pgtype.Text        `json:"p_description"`
	PPrice         int32              `json:"p_price"`
	PStock         int32              `json:"p_stock"`
	PCategory      pgtype.Text        `json:"p_category"`
	PImageUrl      pgtype.Text        `json:"p_image_url"`
	PCreatedAt     pgtype.Timestamptz `json:"p_created_at"`
	PUpdatedAt     pgtype.Timestamptz `json:"p_updated_at"`
}

func (q *Queries) ListActiveDeals(ctx context.Context, arg ListActiveDealsParams) ([]ListActiveDealsRow, error) {
	rows, err := q.db.Query(ctx, listActiveDeals, arg.StartsAt, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveDealsRow
	for rows.Next() {
		var i ListActiveDealsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.DealPrice,
			&i.DealStock,
			&i.RemainingStock,
			&i.StartsAt,
			&i.EndsAt,
			&i.CreatedAt,
			&i.PID,
			&i.PName,
			&i.PDescription,
			&i.PPrice,
			&i.PStock,
			&i.PCategory,
			&i.PImageUrl,
			&i.PCreatedAt,
			&i.PUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT id, name, description, price, stock, category, image_url, created_at, updated_at
FROM product.products
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListProductsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]ProductProduct, error) {
	rows, err := q.db.Query(ctx, listProducts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductProduct
	for rows.Next() {
		var i ProductProduct
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.Stock,
			&i.Category,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsByCategory = `-- name: ListProductsByCategory :many
SELECT id, name, description, price, stock, category, image_url, created_at, updated_at
FROM product.products
WHERE category = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListProductsByCategoryParams struct {
	Category pgtype.Text `json:"category"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListProductsByCategory(ctx context.Context, arg ListProductsByCategoryParams) ([]ProductProduct, error) {
	rows, err := q.db.Query(ctx, listProductsByCategory, arg.Category, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductProduct
	for rows.Next() {
		var i ProductProduct
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.Stock,
			&i.Category,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE product.products
SET name = COALESCE($2, name),
    description = COALESCE($3, description),
    price = COALESCE($4, price),
    category = COALESCE($5, category),
    image_url = COALESCE($6, image_url),
    updated_at = NOW()
WHERE id = $1
RETURNING id, name, description, price, stock, category, image_url, created_at, updated_at
`

type UpdateProductParams struct {
	ID          pgtype.UUID `json:"id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Price       int32       `json:"price"`
	Category    pgtype.Text `json:"category"`
	ImageUrl    pgtype.Text `json:"image_url"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (ProductProduct, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.Category,
		arg.ImageUrl,
	)
	var i ProductProduct
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Stock,
		&i.Category,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateStock = `-- name: UpdateStock :one
UPDATE product.products
SET stock = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, stock, updated_at
`

type UpdateStockParams struct {
	ID    pgtype.UUID `json:"id"`
	Stock int32       `json:"stock"`
}

type UpdateStockRow struct {
	ID        pgtype.UUID        `json:"id"`
	Stock     int32              `json:"stock"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateStock(ctx context.Context, arg UpdateStockParams) (UpdateStockRow, error) {
	row := q.db.QueryRow(ctx, updateStock, arg.ID, arg.Stock)
	var i UpdateStockRow
	err := row.Scan(&i.ID, &i.Stock, &i.UpdatedAt)
	return i, err
}
