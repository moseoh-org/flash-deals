# 다중 서버 환경 선착순 순서 미보장

## 상황

Product Service를 여러 인스턴스로 스케일아웃하면 Go Channel 기반 FIFO 큐가 동작하지 않는다.
각 인스턴스가 독립적인 채널을 가지므로 전역적인 순서 보장이 불가능하다.

## 테스트 환경

- 부하 테스트: `make load-fifo-test`
- Product 인스턴스: 2개 (`docker compose up --scale product=2`)
- 최대 VU: 20 (FIFO)
- 테스트 대상: `POST /orders` (핫딜 주문)

---

## 단일 서버 (Go Channel)

### 구조

```
Order Service → Product Service (1개)
                    └── Go Channel FIFO Queue
                            └── Worker (순차 처리)
```

### 순서 보장 테스트

| 항목       | 기대값               | 실제값               |
| ---------- | -------------------- | -------------------- |
| 성공 유저  | 1,2,3,4,5,6,7,8,9,10 | 1,2,3,4,5,6,7,8,9,10 |
| 총 성공 수 | 10명                 | 10명                 |
| 순서 보장  | O                    | **O (서버측)**       |

### 한계

- 서버 재시작 시 큐 유실 (인메모리)
- 단일 서버만 확장 불가

---

## 다중 서버 (Go Channel)

### 구조

```
                    ┌── Product Service #1
Order Service ──────┤       └── Go Channel Queue #1
    (LB)            │
                    └── Product Service #2
                            └── Go Channel Queue #2
```

### 예상 문제점

| 항목       | 기대값               | 예상 실제값                      |
| ---------- | -------------------- | -------------------------------- |
| 성공 유저  | 1,2,3,4,5,6,7,8,9,10 | 랜덤 10명 (LB 분산에 따라 결정)  |
| 총 성공 수 | 10명                 | 10명                             |
| 순서 보장  | O                    | **X (인스턴스별 독립 큐)**       |

### 원인 분석

- 로드밸런서가 요청을 여러 인스턴스에 분산
- 각 인스턴스의 Go Channel은 독립적으로 동작
- User 1 → Product #1, User 2 → Product #2로 분산되면 전역 순서 유실
- 같은 상품의 재고 업데이트가 서로 다른 큐에서 처리됨

---

## 해결 방안

### 옵션 1: Redis Streams

| 항목     | 내용                                        |
| -------- | ------------------------------------------- |
| 방식     | 외부 메시지 큐로 전역 FIFO 보장             |
| 장점     | 기존 Redis 활용 가능, 설정 간단             |
| 단점     | Consumer Group 중 하나만 처리 (확장성 제한) |
| 적합     | 같은 상품은 순차 처리가 필수인 경우         |

### 옵션 2: Kafka + Partition Key

| 항목     | 내용                                            |
| -------- | ----------------------------------------------- |
| 방식     | deal_id를 Partition Key로 사용                  |
| 장점     | 같은 상품 → 같은 파티션 → 순서 보장 + 확장 가능 |
| 단점     | Kafka 인프라 추가 필요                          |
| 적합     | 대규모 트래픽, 다양한 상품 동시 처리            |

### 옵션 3: DB Advisory Lock

| 항목     | 내용                                   |
| -------- | -------------------------------------- |
| 방식     | PostgreSQL Advisory Lock으로 전역 락   |
| 장점     | 추가 인프라 불필요                     |
| 단점     | DB 부하 증가, 확장성 제한              |
| 적합     | 소규모 트래픽, 간단한 구현 선호        |

---

## 비교 요약

| 환경        | 순서 보장 | 확장성 | 내구성 | 구현 복잡도 |
| ----------- | --------- | ------ | ------ | ----------- |
| 단일 서버   | O         | X      | X      | 낮음        |
| Redis       | O         | 제한적 | O      | 중간        |
| Kafka       | O         | O      | O      | 높음        |
| DB Lock     | O         | X      | O      | 낮음        |

> 현재 프로젝트는 단일 서버 + Go Channel로 FIFO 보장 구현 완료.
> 다중 서버 확장 시 Redis Streams 또는 Kafka 도입 검토 필요.
