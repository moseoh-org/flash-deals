# 재고 차감 시 Lock 경합

## 상황

핫딜 상품에 동시 주문이 몰릴 때 DB Lock 경합으로 인해 처리량이 저하된다.
SELECT FOR UPDATE로 oversell은 방지되지만, lock 대기 중에도 커넥션을 점유하여 효율이 떨어진다.

## 테스트 환경

- 부하 테스트: `make load-order-stress`
- 최대 VU: 50
- 테스트 대상: `POST /orders` (핫딜 주문)

---

## 기존 시스템 (SELECT FOR UPDATE)

### 동작 방식

```
요청 1 ──┐
요청 2 ──┼── 동시에 DB Lock 획득 시도
요청 3 ──┘
           ↓
    Lock 획득: 요청 1 (처리 중)
    Lock 대기: 요청 2, 3 (커넥션 점유 상태)
           ↓
    요청 1 완료 → 요청 2 Lock 획득...
```

### 성능

| 지표          | 값       |
| ------------- | -------- |
| p95 응답시간  | 19ms     |
| 평균 응답시간 | 9ms      |
| 처리량        | 160req/s |
| 에러율        | 0%       |

### 문제점

- 동시 요청이 많을수록 lock 대기 시간 증가
- Lock 대기 중에도 DB 커넥션 점유 → 커넥션 풀 고갈 위험
- 트랜잭션 시간 증가 → 전체 처리량 저하

---

## 개선: Go Channel (순차 처리)

### 변경 내용

- Go Channel을 버퍼 큐로 활용 (버퍼: 10,000)
- 단일 Worker가 순차적으로 재고 업데이트 처리
- Lock 경합 없이 한 번에 하나씩 처리
- 구현: `services/product/go/internal/queue/stock_queue.go`

### 동작 방식

```
요청 1 ──┐
요청 2 ──┼── Channel에 순차 적재 (즉시 반환 대기)
요청 3 ──┘
           ↓
    Worker: 요청 1 처리 → 요청 2 처리 → 요청 3 처리
           ↓
    Lock 경합 없음, 커넥션 즉시 반환
```

### 성능

| 지표          | Before   | After    | 개선    |
| ------------- | -------- | -------- | ------- |
| p95 응답시간  | 19ms     | 14ms     | 26% ↓   |
| 평균 응답시간 | 9ms      | 6ms      | 33% ↓   |
| 처리량        | 160req/s | 303req/s | 1.9배 ↑ |
| 에러율        | 0%       | 0%       | -       |

### 분석

- **Lock 경합 제거**: 순차 처리로 DB Lock 대기 시간 0
- **커넥션 효율 증가**: 트랜잭션 즉시 완료 → 커넥션 풀 여유
- **처리량 향상**: 1.9배 개선

---

## 비교 요약

| 항목          | SELECT FOR UPDATE | Go Channel   |
| ------------- | ----------------- | ------------ |
| 처리량        | 160req/s          | 303req/s     |
| Lock 경합     | O (대기 발생)     | X (순차 처리) |
| 커넥션 효율   | 낮음              | 높음         |
| oversell 방지 | O                 | O            |
