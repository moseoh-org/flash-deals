# 선착순 주문 순서 미보장

## 상황

핫딜 상품 구매 시 먼저 요청한 사용자가 구매에 실패하는 현상이 발생한다.
재고 10개인 상품에 User 1~20이 순서대로 요청했으나, 구매 성공자가 1~10이 아닌 랜덤한 10명이다.

## 테스트 환경

- 부하 테스트: `make load-fifo-test`
- 최대 VU: 20
- 테스트 대상: `POST /orders` (핫딜 주문)
- 조건: 재고 10개 상품, 20명 순차 요청 (1ms 간격)

---

## 기존 시스템

### 동작 방식

```
User 1 요청 (T=0ms)  → Goroutine A → DB 트랜잭션 (50ms)
User 2 요청 (T=1ms)  → Goroutine B → DB 트랜잭션 (30ms) ← 먼저 완료
User 3 요청 (T=2ms)  → Goroutine C → DB 트랜잭션 (20ms) ← 가장 먼저 완료
```

### 문제점

- TCP 요청 순서 ≠ 처리 완료 순서
- 멀티스레드 환경에서 동시 처리로 인해 순서 역전 발생
- "선착순"이 아닌 "빨리 처리된 순"으로 동작

### 테스트 결과

| 항목 | 기대값 | 실제값 |
| ---- | ------ | ------ |
| 성공 유저 | 1,2,3,4,5,6,7,8,9,10 | 1,3,5,8,11,12,14,16,18,20 (랜덤) |
| 총 성공 수 | 10명 | 10명 |
| 순서 보장 | O | X |

---

## 개선 1: Go Channel (인메모리 큐)

### 변경 내용

- Go Channel을 FIFO 큐로 활용
- API는 즉시 "대기 중" 응답 반환 (202 Accepted)
- Worker goroutine이 순차적으로 처리

### 예상 결과

| 항목 | 기존 | 개선 후 |
| ---- | ---- | ------- |
| 성공 유저 | 랜덤 10명 | 1~10 순서대로 |
| 순서 보장 | X | O |

### 분석

- 구현 간단 (Kafka 불필요)
- 단일 서버 전용
- 서버 재시작 시 큐 데이터 유실

---

## 개선 2: Kafka (분산 메시지 큐)

### 변경 내용

- Kafka Topic으로 주문 요청 발행
- deal_id를 Partition Key로 사용 → 같은 상품 주문은 같은 파티션
- Consumer가 파티션 내 순차 처리

### 예상 결과

| 항목 | Go Channel | Kafka |
| ---- | ---------- | ----- |
| 순서 보장 | O | O |
| 내구성 | X | O |
| 다중 서버 | X | O |

### 분석

- 순서 보장 + 메시지 내구성
- 서버 재시작에도 데이터 유지
- 다중 서버 환경 지원

---

## 비교 요약

| 항목 | 현재 (동시) | Go Channel | Kafka |
| ---- | ----------- | ---------- | ----- |
| 순서 보장 | X | O | O |
| 내구성 | - | X | O |
| 다중 서버 | - | X | O |
| 복잡도 | 낮음 | 낮음 | 높음 |
| 적합 환경 | 순서 무관 | 단일 서버 | 프로덕션 |
